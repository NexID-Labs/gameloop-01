<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spyfall Game - Playing</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="custom/custom.css" rel="stylesheet" type="text/css">
  <style>
    body {
      padding: 20px;
      padding-top: 80px; /* Account for ad banner */
      background-image: url(./gallary/background-motion.png);
background-size: cover;
  background-repeat: no-repeat;
  background-position: center center;
  transition: background-image 1s ease-in-out;
    }

    .text-center h3 {
      font-family: 'AbdoMaster';
      font-size: 40px;
      color: #fff;
    }

.player-box {
  border: 1px solid #ccc;
  border-radius: 5px;
  padding: 5px 10px;
  display: inline-flex;
  align-items: center;
  margin: 2px;
  font-family: 'AbdoMaster';
  color: #fff;
  text-align: center;
  margin: 0 auto;
  width: fit-content;
  width: 100%;
  display: flex;
  justify-content: center;
}


    .host-number {
      font-weight: bold;
      color: #ffcc00;
      margin-right: 5px;
    }
    .host-number {
  font-weight: bold;
  color: #ffcc00;
  margin-right: 5px;
  display: none!important;
}

    .guess-option {
      margin-bottom: 10px;
      width: 100%;
    }

 .waiting-text {
  color: white;
  font-style: italic;
  margin-bottom: 10px;
  position: absolute;
  bottom: 30px;
  font-family: 'AbdoMaster';
  font-size: 16px;
  color: #fff;
  text-align: center;
  text-align: center;
  margin: 0 auto;
}

/* New Features Styles */
/* Ad Banner Styles */
.ad-banner {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 60px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.ad-content {
  color: white;
  font-weight: bold;
  font-size: 16px;
  text-align: center;
}

.ad-text {
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

/* Points Dashboard Styles */
.points-dashboard {
  position: fixed;
  top: 70px;
  right: 10px;
  width: 200px;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 15px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  z-index: 999;
  overflow: hidden;
}

.dashboard-header {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 8px 12px;
  font-weight: bold;
  font-size: 14px;
  text-align: center;
}

.dashboard-title {
  font-size: 12px;
}

.points-container {
  padding: 10px;
  max-height: 200px;
  overflow-y: auto;
}

.player-score {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 8px;
  margin: 3px 0;
  background: #f8f9fa;
  border-radius: 8px;
  font-size: 12px;
  color: #333;
  transition: all 0.3s ease;
}

.player-score:hover {
  background: #e9ecef;
  transform: translateX(3px);
}

.player-name {
  font-weight: bold;
  max-width: 120px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.player-points {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 2px 8px;
  border-radius: 12px;
  font-weight: bold;
  font-size: 11px;
}

/* Notification System Styles */
.notification-container {
  position: fixed;
  top: 70px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 998;
  width: 90%;
  max-width: 400px;
}

.notification {
  background: rgba(255, 255, 255, 0.95);
  border-left: 4px solid #667eea;
  padding: 12px 16px;
  margin: 8px 0;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
  animation: slideInDown 0.5s ease, fadeOut 0.5s ease 4.5s forwards;
  color: #333;
  font-weight: 500;
}

.notification.success {
  border-left-color: #28a745;
  background: rgba(212, 237, 218, 0.95);
}

.notification.info {
  border-left-color: #17a2b8;
  background: rgba(209, 236, 241, 0.95);
}

.notification.warning {
  border-left-color: #ffc107;
  background: rgba(255, 243, 205, 0.95);
}

@keyframes slideInDown {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeOut {
  to {
    opacity: 0;
    transform: translateY(-20px);
  }
}

/* Responsive Design */
@media (max-width: 768px) {
  .points-dashboard {
    width: 180px;
    right: 5px;
  }

  .dashboard-title {
    font-size: 11px;
  }

  .player-score {
    font-size: 11px;
  }

  .notification-container {
    width: 95%;
  }

  .ad-banner {
    height: 50px;
  }

  .ad-content {
    font-size: 14px;
  }
}

@media (max-width: 480px) {
  .points-dashboard {
    width: 160px;
    top: 60px;
  }

  .player-name {
    max-width: 100px;
  }
}
  </style>
</head>

<body>
  <script>
        document.addEventListener("DOMContentLoaded", function () {
    const backgrounds=[ "gallary/picture/1.PNG",
    "gallary/picture/2.PNG",
    "gallary/picture/3.PNG",
    "gallary/picture/4.PNG",
    "gallary/picture/5.PNG",
    "gallary/picture/6.PNG",
    "gallary/picture/7.PNG",
    "gallary/picture/8.PNG",
    "gallary/picture/9.PNG",
    "gallary/picture/10.PNG",
    "gallary/picture/11.PNG",
    "gallary/picture/12.PNG",
    "gallary/picture/13.PNG",
    "gallary/picture/14.PNG",
    "gallary/picture/15.PNG",
        "gallary/picture/16.PNG",
    "gallary/picture/17.PNG",
    "gallary/picture/18.PNG"
    ];

    const selectedBg = backgrounds[Math.floor(Math.random() * backgrounds.length)];

    document.body.style.backgroundImage = `url('${selectedBg}')`;
  });
</script>
  <!-- Top Ad Banner -->
  <div id="adBanner" class="ad-banner">
    <div class="ad-content">
      <span class="ad-text">üéÆ Your Ad Here - Premium Gaming Experience</span>
    </div>
  </div>

  <!-- Points Dashboard -->
  <div id="pointsDashboard" class="points-dashboard">
    <div class="dashboard-header">
      <span class="dashboard-title">üèÜ Live Scores</span>
    </div>
    <div id="pointsContainer" class="points-container">
      <!-- Points will be populated here -->
    </div>
  </div>

  <!-- Notification System -->
  <div id="notificationContainer" class="notification-container">
    <!-- Notifications will appear here -->
  </div>

  <div class="container text-center">
    <img src="gallary/name-12.png" class="img-fluid" alt="img">
    <p><span id="timer">00:00</span></p>
    <p id="questionProgress" class="text-info mb-2">Question 1/20</p>
    <h3>ÿ™ŸÇÿØÿ±ŸàŸÜ ÿ™ÿ¨ÿßŸàÿ®ŸàŸÜ ÿßŸÑÿ≠€åŸÜ</h3>
    <div id="questionSection"></div>

    <div id="optionsContainer" class="mb-3"></div>

    <button id="submitAnswerBtn" class="btn btn-success mb-2 d-none">Submit Answer</button>
    <button id="nextBtn" class="btn btn-primary">Next</button>
    <button id="endBtn" class="btn btn-danger d-none">End Game</button>

    <h5>Players</h5>
    <div id="playersContainer" class="d-flex flex-wrap justify-content-center"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4.0.0/dist/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    // Load environment variables
    const env = {};
    fetch('/.env')
      .then(response => response.text())
      .then(data => {
        const lines = data.split('\n');
        lines.forEach(line => {
          const [key, value] = line.split('=');
          if (key && value) {
            env[key.trim()] = value.trim();
          }
        });
      });

    const socket = io.connect(env.BACKEND_URL);

    const urlParams = new URLSearchParams(window.location.search);
    const accessCode = urlParams.get("code") || "testcode";
    const savedPlayerName = localStorage.getItem("playerName") || "Player";

    const playersContainer = document.getElementById("playersContainer");
    const questionSection = document.getElementById("questionSection");
    const optionsContainer = document.getElementById("optionsContainer");
    const submitAnswerBtn = document.getElementById("submitAnswerBtn");
    const nextBtn = document.getElementById("nextBtn");
    const endBtn = document.getElementById("endBtn");

    let globalTimerInterval;
    let questionLimit = 20; // Default value
    let currentQuestionNumber = 0;
    let gameStartTime = null;
    let gameDuration = 0; // Will be set based on questionLimit

    let selectedOption = null;
    let isLastQuestion = false;

    let hostName = "";

    let questionLimitLoaded = false;

    // ‚úÖ Questions Array - Will be loaded from backend
    let sampleQuestions = [];
    let questionsLoaded = false;
    let currentAds = [];
    let currentAdIndex = 0;

    // Load questions from backend
    function loadQuestionsFromBackend() {
      fetch(`${env.BACKEND_URL}/api/admin/questions`)
        .then(response => response.json())
        .then(questions => {
          sampleQuestions = questions;
          questionsLoaded = true;
          console.log('Loaded questions from backend:', sampleQuestions.length);

          // If no questions in admin panel, use fallback questions
          if (sampleQuestions.length === 0) {
            sampleQuestions = [
              { q: "What do you usually wear at this place?", options: ["Give up all rice dishes!", "Give up Italian!"] },
              { q: "Is this place noisy?", options: ["Disneyland in Kuwait.", "Snow in Kuwait."] },
              { q: "Would you rather?", options: ["One week traffic 24/7", "1 week no air conditioning in car in Summer."] },
              { q: "Would you rather?", options: ["Ramadan with no desserts", "Ramadan with no tea/coffee"] },
              { q: "Would you rather?", options: ["Act in a Kuwait Masraheya", "Act in a Kuwaiti TV show"] },
              { q: "Would you rather?", options: ["Family member points out you are wearing knock off at Zwara", "Realize in the middle of avenues there is a huge stain on the back of your clothes."] },
              { q: "Would you rather?", options: ["Eat a whole lemon", "Eat a whole lime"] },
              { q: "Would you rather?", options: ["Have purple hair for a year", "Have no hair for a year"] },
              { q: "Would you rather?", options: ["Never use social media again", "Never watch TV again"] },
              { q: "Would you rather?", options: ["Have the ability to fly", "Have the ability to read minds"] }
            ];
            console.log('Using fallback questions');
          }
        })
        .catch(error => {
          console.error('Error loading questions from backend:', error);
          // Use fallback questions
          sampleQuestions = [
            { q: "What do you usually wear at this place?", options: ["Give up all rice dishes!", "Give up Italian!"] },
            { q: "Is this place noisy?", options: ["Disneyland in Kuwait.", "Snow in Kuwait."] },
            { q: "Would you rather?", options: ["One week traffic 24/7", "1 week no air conditioning in car in Summer."] }
          ];
          questionsLoaded = true;
        });
    }

    // Load ads from backend
    function loadAdsFromBackend() {
      fetch(`${env.BACKEND_URL}/api/admin/ads`)
        .then(response => response.json())
        .then(ads => {
          currentAds = ads.filter(ad => ad.status === 'active');
          console.log('Loaded active ads from backend:', currentAds.length);

          // If no ads in admin panel, use default ad
          if (currentAds.length === 0) {
            currentAds = [{
              title: "Default Ad",
              content: "üéÆ Your Ad Here - Premium Gaming Experience",
              url: ""
            }];
          }

          // Initialize ad rotation
          initializeAdRotation();
        })
        .catch(error => {
          console.error('Error loading ads from backend:', error);
          // Use default ad
          currentAds = [{
            title: "Default Ad",
            content: "üéÆ Your Ad Here - Premium Gaming Experience",
            url: ""
          }];
          initializeAdRotation();
        });
    }

    // Initialize ad rotation
    function initializeAdRotation() {
      if (currentAds.length > 0) {
        updateAdBanner();

        // Rotate ads every 30 seconds if there are multiple ads
        if (currentAds.length > 1) {
          setInterval(() => {
            currentAdIndex = (currentAdIndex + 1) % currentAds.length;
            updateAdBanner();
          }, 30000);
        }
      }
    }

    // Update ad banner content
    function updateAdBanner() {
      const adBanner = document.getElementById('adBanner');
      const adText = adBanner.querySelector('.ad-text');

      if (currentAds.length > 0) {
        const currentAd = currentAds[currentAdIndex];
        adText.textContent = currentAd.content;

        // Make ad clickable if URL is provided
        if (currentAd.url) {
          adBanner.style.cursor = 'pointer';
          adBanner.onclick = () => window.open(currentAd.url, '_blank');
        } else {
          adBanner.style.cursor = 'default';
          adBanner.onclick = null;
        }
      }
    }

    // Initialize game data - load questions, ads, and game settings
    Promise.all([
      loadQuestionsFromBackend(),
      loadAdsFromBackend()
    ]).then(() => {
      console.log('All game data loaded successfully');

      // Get question limit and initialize game timer
      fetch(`${env.BACKEND_URL}/api/game/${accessCode}`)
        .then(response => response.json())
        .then(game => {
          if (game.questionLimit) {
            questionLimit = game.questionLimit;
            gameDuration = questionLimit * 60; // 1 minute per question
            document.getElementById("questionProgress").textContent = `Question 1/${questionLimit}`;
            // Show initial timer duration
            document.getElementById("timer").textContent = formatTime(gameDuration);
            questionLimitLoaded = true;
          }

          if (game.host) {
            hostName = game.host;
          }
        })
        .catch(error => {
          console.error('Error loading game data:', error);
          // Continue with fallback data
          questionLimit = 20;
          gameDuration = questionLimit * 60;
          document.getElementById("questionProgress").textContent = `Question 1/${questionLimit}`;
          document.getElementById("timer").textContent = formatTime(gameDuration);
          questionLimitLoaded = true;
        });
    });

    function initializeGlobalTimer() {
      const now = Date.now();
      fetch(`${env.BACKEND_URL}/api/game/${accessCode}/start`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ startTime: now, duration: gameDuration })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          gameStartTime = now;
          document.getElementById("questionProgress").textContent = `Question ${currentQuestionNumber}/${questionLimit}`;
          startGlobalTimer();
        }
      })
      .catch(error => {
        console.error('Error starting game timer:', error);
      });
    }

    function startGlobalTimer() {
      clearInterval(globalTimerInterval);
      globalTimerInterval = setInterval(() => {
        updateGlobalTimer();
      }, 1000);
    }

    function updateGlobalTimer() {
      if (!gameStartTime || !gameDuration) return;

      const now = Date.now();
      const elapsed = Math.floor((now - gameStartTime) / 1000);
      const remaining = Math.max(0, gameDuration - elapsed);

      const timerElement = document.getElementById("timer");
      if (timerElement) {
        timerElement.textContent = formatTime(remaining);
      }

      if (remaining <= 0) {
        endGameDueToTimer();
      }
    }

    function endGameDueToTimer() {
      clearInterval(globalTimerInterval);
      alert("Time's up! Game ended.");
      calculateAndSetWinner().then(() => {
        window.location.href = `scoring.html?code=${accessCode}`;
      });
    }

    function formatTime(t) {
      const m = Math.floor(t / 60).toString().padStart(2, "0");
      const s = (t % 60).toString().padStart(2, "0");
      return `${m}:${s}`;
    }

    function calculateAndSetWinner() {
      return fetch(`${env.BACKEND_URL}/api/game/${accessCode}/end`, {
        method: 'POST'
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          window.location.href = `scoring.html?code=${accessCode}`;
        }
      })
      .catch(error => {
        console.error('Error ending game:', error);
      });
    }

    function renderPlayers(playersObj) {
      playersContainer.innerHTML = "";
      Object.keys(playersObj).forEach(name => {
        const div = document.createElement("div");
        div.className = "player-box";

        if (name === hostName) {
          div.innerHTML = `<span class="host-number">1</span> ${name}`;
        } else {
          div.textContent = name;
        }

        playersContainer.appendChild(div);
      });
    }

    // Helper functions for turn-based submission
    function getCurrentPlayerTurn(qData) {
      if (!qData || !qData.submissionOrder || qData.currentSubmissionIndex === undefined) {
        return null;
      }
      return qData.submissionOrder[qData.currentSubmissionIndex];
    }

    function canPlayerSubmit(qData, playerName) {
      const currentPlayer = getCurrentPlayerTurn(qData);
      return currentPlayer === playerName;
    }

    function advanceToNextPlayer(qData) {
      const nextIndex = qData.currentSubmissionIndex + 1;
      if (nextIndex < qData.submissionOrder.length) {
        fetch(`${env.BACKEND_URL}/api/game/${accessCode}/question`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ currentSubmissionIndex: nextIndex })
        })
        .catch(error => {
          console.error('Error updating question state:', error);
        });
      }
    }

    function allPlayersSubmitted(qData) {
      return qData.currentSubmissionIndex >= qData.submissionOrder.length - 1;
    }

    function nextQuestionTurn(currentPlayers) {
      const playerNames = Object.keys(currentPlayers);

      // Check if we've reached the question limit
      if (currentQuestionNumber >= questionLimit) {
        endGameDueToQuestionLimit();
        return;
      }

      // Continue asking questions until question limit is reached
      isLastQuestion = currentQuestionNumber >= questionLimit - 1;

      // Select a random player for each question (not based on who has played)
      const nextPlayer = playerNames[Math.floor(Math.random() * playerNames.length)];

      // Ensure questions are loaded before proceeding
      if (!questionsLoaded || !sampleQuestions || sampleQuestions.length === 0) {
        console.log("Questions not loaded yet, waiting...");
        // Try to load questions again if not loaded
        if (!questionsLoaded) {
          loadQuestionsFromBackend().then(() => {
            if (sampleQuestions.length > 0) {
              nextQuestionTurn(currentPlayers); // Retry after loading
            } else {
              alert("No questions available. Please add questions through the admin panel.");
            }
          });
        } else {
          alert("No questions available. Please add questions through the admin panel.");
        }
        return;
      }

      const q = sampleQuestions[Math.floor(Math.random() * sampleQuestions.length)];
      console.log("Selected question:", q);

      // Increment question count
      currentQuestionNumber++;

      // Initialize timer on first question (wait for questionLimit to load)
      if (currentQuestionNumber === 1 && !gameStartTime) {
        if (questionLimitLoaded) {
          initializeGlobalTimer();
        } else {
          // Wait for questionLimit to load, then initialize
          fetch(`${env.BACKEND_URL}/api/game/${accessCode}`)
            .then(response => response.json())
            .then(game => {
              if (game.questionLimit) {
                questionLimit = game.questionLimit;
                gameDuration = questionLimit * 60;
                initializeGlobalTimer();
              }
            })
            .catch(error => {
              console.error('Error loading game data:', error);
            });
        }
      } else {
        // Update question count in backend for existing game
        fetch(`${env.BACKEND_URL}/api/game/${accessCode}/questionCount`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ questionCount: currentQuestionNumber })
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            document.getElementById("questionProgress").textContent = `Question ${currentQuestionNumber}/${questionLimit}`;
          }
        })
        .catch(error => {
          console.error('Error updating question count:', error);
        });
      }

      // Create submission order: askedTo player first, then others
      const submissionOrder = [nextPlayer];
      playerNames.forEach(name => {
        if (name !== nextPlayer) {
          submissionOrder.push(name);
        }
      });

      const questionData = {
        question: q.q || "",
        options: q.options || [],
        askedTo: nextPlayer,
        selectedAnswer: null,
        guesses: {},
        completedPlayers: {},
        submissionOrder: submissionOrder,
        currentSubmissionIndex: 0
      };

      console.log("Setting question data in backend:", questionData);

      fetch(`${env.BACKEND_URL}/api/game/${accessCode}/question`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(questionData)
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          console.log("Question set successfully in backend");
        }
      })
      .catch(error => {
        console.error("Error setting question in backend:", error);
      });

      // Don't set played flag - we want to continue asking questions until limit is reached

      nextBtn.classList.toggle("d-none", isLastQuestion);
      endBtn.classList.toggle("d-none", !isLastQuestion);
    }

    function endGameDueToQuestionLimit() {
      clearInterval(globalTimerInterval);
      alert("All questions completed! Game ended.");
      calculateAndSetWinner().then(() => {
        window.location.href = `scoring.html?code=${accessCode}`;
      });
    }

    // Join the game room
    socket.emit('joinGame', accessCode);

    // Listen for game data
    socket.on('gameData', (game) => {
      if (!game) {
        alert("Game not found.");
        window.location.href = "index.html";
        return;
      }

      // Update players list
      renderPlayers(game.players || {});

      // Listen for real-time updates
      socket.on('gameUpdated', (updatedGame) => {
        renderPlayers(updatedGame.players || {});
      });
    });

    // Listen for game not found
    socket.on('gameNotFound', (data) => {
      alert(data.message);
      window.location.href = "index.html";
    });

    // Listen for player joined
    socket.on('playerJoined', (data) => {
      console.log('Player joined:', data.playerId);
    });

    // Listen for game started
    socket.on('gameStarted', () => {
      window.location.href = `finalpage.html?code=${accessCode}`;
    });

    // Listen for game ended
    socket.on('gameEnded', () => {
      window.location.href = `scoring.html?code=${accessCode}`;
    });

    // Sync question count and timer on page load
    fetch(`${env.BACKEND_URL}/api/game/${accessCode}/questionCount`)
      .then(response => response.json())
      .then(data => {
        if (data.questionCount) {
          currentQuestionNumber = data.questionCount;
          document.getElementById("questionProgress").textContent = `Question ${currentQuestionNumber}/${questionLimit}`;
        }
      })
      .catch(error => {
        console.error('Error fetching question count:', error);
      });

    // Check if game has ended due to timer
    fetch(`${env.BACKEND_URL}/api/game/${accessCode}/ended`)
      .then(response => response.json())
      .then(data => {
        if (data.ended) {
          window.location.href = `scoring.html?code=${accessCode}`;
        }
      })
      .catch(error => {
        console.error('Error checking game status:', error);
      });

    // Initialize the new features
    initializePointsDashboard();

    // Show welcome notification
    setTimeout(() => {
      showNotification("üéÆ Welcome to the game! Points will update live as you play.", 'info');
    }, 1000);
  </script>
</body>

</html>
